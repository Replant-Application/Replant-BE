name: Build, Test, Scan, and Deploy Web with Docker + SonarCloud + Snyk + Trivy

on:
  push:
    branches: ["main"]

# Í∞ôÏùÄ Î∏åÎûúÏπòÏóêÏÑú Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄ
concurrency:
  group: web-ci-cd-${{ github.ref }}
  cancel-in-progress: true

# ÏµúÏÜå Í∂åÌïú
permissions:
  contents: read

env:
  IMAGE_NAME: your-image-name
  REGISTRY: docker.io
  IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Create .env from secrets
        run: |
          echo "DB1_URL=${{ secrets.DB1_URL }}" >> .env
          echo "DB1_USERNAME=${{ secrets.DB1_USERNAME }}" >> .env
          echo "DB1_PASSWORD=${{ secrets.DB1_PASSWORD }}" >> .env
          echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env
          echo "REDIS_PORT=${{ secrets.REDIS_PORT }}" >> .env
          echo "REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}" >> .env
          echo "JWT=${{ secrets.JWT }}" >> .env
          echo "S3_BUCKET=${{ secrets.S3_BUCKET }}" >> .env
          echo "S3_ACCESS_KEY=${{ secrets.S3_ACCESS_KEY }}" >> .env
          echo "S3_SECRET_KEY=${{ secrets.S3_SECRET_KEY }}" >> .env
          echo "S3_CLIENT=${{ secrets.S3_CLIENT }}" >> .env
          echo "S3_REGION=${{ secrets.S3_REGION }}" >> .env
          echo "GOOGLE_MAIL=${{ secrets.GOOGLE_MAIL }}" >> .env
          echo "GOOGLE_APP_PASSWORD=${{ secrets.GOOGLE_APP_PASSWORD }}" >> .env
          echo "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" >> .env
          echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env
          echo "GEMINI_PROJECT_ID=${{ secrets.GEMINI_PROJECT_ID }}" >> .env
          echo "GEMINI_MODEL=${{ secrets.GEMINI_MODEL }}" >> .env
          echo "GEMINI_TEMPERATURE=${{ secrets.GEMINI_TEMPERATURE }}" >> .env
          echo "QWEN_API_URL=${{ secrets.QWEN_API_URL }}" >> .env
          echo "QWEN_API_KEY=${{ secrets.QWEN_API_KEY }}" >> .env
          echo "QWEN_MODEL=${{ secrets.QWEN_MODEL }}" >> .env
          echo "QWEN_TEMPERATURE=${{ secrets.QWEN_TEMPERATURE }}" >> .env

      - name: Run tests
        env:
          JWT: ${{ secrets.JWT }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_PROJECT_ID: ${{ secrets.GEMINI_PROJECT_ID }}
          GEMINI_LOCATION: ${{ secrets.GEMINI_LOCATION }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL }}
          GEMINI_TEMPERATURE: ${{ secrets.GEMINI_TEMPERATURE }}
          QWEN_API_URL: ${{ secrets.QWEN_API_URL }}
          QWEN_API_KEY: ${{ secrets.QWEN_API_KEY }}
          QWEN_MODEL: ${{ secrets.QWEN_MODEL }}
          QWEN_TEMPERATURE: ${{ secrets.QWEN_TEMPERATURE }}
        run: ./gradlew test

  snyk_scan:
    name: Run Snyk SCA Scan (gate)
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        id: setup-java
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew build -x test

      - name: Install Snyk CLI
        run: |
          npm install -g snyk

      # Ï∑®ÏïΩÏ†ê ÏûàÏúºÎ©¥ Ïã§Ìå®ÌïòÎèÑÎ°ù test ÏÇ¨Ïö© (Í≤åÏù¥Ìä∏)
      - name: Run Snyk test (fail on HIGH+)
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          snyk test --severity-threshold=high --all-projects || true
          snyk test --severity-threshold=high --all-projects

      # (ÏÑ†ÌÉù) Í≤∞Í≥ºÎ•º Snyk ÎåÄÏãúÎ≥¥ÎìúÏóê ÏóÖÎ°úÎìú
      - name: Run Snyk monitor (optional)
        if: always()
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: |
          snyk monitor --all-projects

  sonarcloud_scan:
    name: Run SonarCloud SAST Scan (gate)
    needs: snyk_scan
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build with Gradle
        run: ./gradlew build -x test

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@v3
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          args: >
            -Dsonar.projectKey=${{ secrets.SONAR_PROJECT_KEY }}
            -Dsonar.organization=${{ secrets.SONAR_ORG }}
            -Dsonar.projectName=${{ secrets.SONAR_PROJECT_NAME }}
            -Dsonar.sources=src
            -Dsonar.java.binaries=build/classes
            -Dsonar.host.url=https://sonarcloud.io
            -Dsonar.scanner.force-deprecated-java-version=true

  docker_build_and_push:
    name: Build and Push Docker Image
    needs: sonarcloud_scan
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: gradle

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Build JAR with Gradle
        run: ./gradlew clean bootJar -x test

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  trivy_scan:
    name: Run Trivy Image Scan (gate + report + slack)
    needs: docker_build_and_push
    runs-on: ubuntu-latest
    steps:
      - name: Set image reference
        run: |
          echo "IMAGE_REF=${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Pull image
        run: docker pull "${IMAGE_REF}"

      - name: Download Trivy HTML Template
        run: |
          mkdir -p .trivy
          curl -sSfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/html.tpl -o .trivy/html.tpl

      - name: Trivy report (HTML)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE_REF }}
          format: template
          template: "@.trivy/html.tpl"
          output: trivy-report.html
          exit-code: "0"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

      - name: Upload Trivy Report as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-report
          path: trivy-report.html

      - name: Trivy scan (JSON for Slack)
        if: always()
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE_REF }}
          format: json
          output: trivy-result.json
          exit-code: "0"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

      - name: Send Trivy CVE summary to Slack
        if: always()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          IMAGE_REF: ${{ env.IMAGE_REF }}
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq

          SUMMARY=$(jq -r '
            [
              .Results[]?
              | .Vulnerabilities[]?
              | select(.Severity=="CRITICAL" or .Severity=="HIGH")
              | "- \(.Severity) \(.VulnerabilityID) | \(.PkgName) \(.InstalledVersion) -> \(.FixedVersion // "unfixed")"
            ]
            | unique
            | .[0:25]
            | join("\n")
          ' trivy-result.json)

          if [ -z "$SUMMARY" ] || [ "$SUMMARY" = "null" ]; then
            TEXT="‚úÖ Trivy: CRITICAL/HIGH ÏóÜÏùå\n‚Ä¢ Image: ${IMAGE_REF}\n‚Ä¢ Run: ${GITHUB_RUN_URL}"
          else
            TEXT="üö® Trivy Î∞úÍ≤¨ (CRITICAL/HIGH)\n‚Ä¢ Repo: ${GITHUB_REPO}\n‚Ä¢ Image: ${IMAGE_REF}\n‚Ä¢ Run: ${GITHUB_RUN_URL}\n\n${SUMMARY}"
          fi

          jq -n --arg text "$TEXT" '{text:$text}' \
            | curl -sSf -X POST -H 'Content-type: application/json' --data @- "$SLACK_WEBHOOK_URL"

      - name: Trivy gate (fail on CRITICAL/HIGH)
        uses: aquasecurity/trivy-action@0.28.0
        with:
          image-ref: ${{ env.IMAGE_REF }}
          format: table
          exit-code: "1"
          ignore-unfixed: true
          vuln-type: "os,library"
          severity: "CRITICAL,HIGH"

      - name: Show Report Summary
        if: always()
        run: |
          echo "## Trivy Scan Report" >> "$GITHUB_STEP_SUMMARY"
          echo "ArtifactÎ°ú trivy-report.html ÏóÖÎ°úÎìú ÏôÑÎ£å" >> "$GITHUB_STEP_SUMMARY"
          echo "- Image: $IMAGE_REF" >> "$GITHUB_STEP_SUMMARY"

  deploy:
    name: Deploy to EC2 (Docker Run)
    needs: trivy_scan
    runs-on: ubuntu-latest
    steps:
      - name: Set environment variables
        run: |
          echo "IMAGE_REF=${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}" >> $GITHUB_ENV
          echo "CONTAINER_NAME=${{ env.IMAGE_NAME }}" >> $GITHUB_ENV

      - name: Set up SSH Key
        run: |
          echo "${{ secrets.EC2_SSH_KEY }}" > /tmp/id_rsa
          chmod 600 /tmp/id_rsa

      # FCM Admin SDK JSON: Î†àÌè¨Ïóê Ïò¨Î¶¨Î©¥ ÌÇ§ Ïú†Ï∂ú ‚Üí GitHub SecretÏóê Base64Î°ú Ï†ÄÏû• ÌõÑ Î∞∞Ìè¨ Ïãú EC2Ïóê ÌååÏùº ÏÉùÏÑ±
      - name: Upload Firebase Admin SDK JSON to EC2
        env:
          EC2_HOST: ${{ secrets.EC2_PUBLIC_IP }}
          EC2_USER: ${{ secrets.EC2_SSH_USER }}
          FIREBASE_ADMIN_SDK_JSON_BASE64: ${{ secrets.FIREBASE_ADMIN_SDK_JSON_BASE64 }}
        run: |
          echo "$FIREBASE_ADMIN_SDK_JSON_BASE64" | base64 -d > /tmp/replant-admin.json
          ssh -o StrictHostKeyChecking=no -i /tmp/id_rsa ${EC2_USER}@${EC2_HOST} "mkdir -p /opt/replant/firebase"
          scp -o StrictHostKeyChecking=no -i /tmp/id_rsa /tmp/replant-admin.json ${EC2_USER}@${EC2_HOST}:/opt/replant/firebase/replant-admin.json
          rm -f /tmp/replant-admin.json

      - name: Deploy via SSH
        env:
          EC2_HOST: ${{ secrets.EC2_PUBLIC_IP }}
          EC2_USER: ${{ secrets.EC2_SSH_USER }}
          DOCKER_USER: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASS: ${{ secrets.DOCKER_PASSWORD }}
          IMAGE_REF: ${{ env.IMAGE_REF }}
          CONTAINER_NAME: ${{ env.CONTAINER_NAME }}
          # ÌôòÍ≤Ω Î≥ÄÏàòÎì§
          DB1_URL: ${{ secrets.DB1_URL }}
          DB1_USERNAME: ${{ secrets.DB1_USERNAME }}
          DB1_PASSWORD: ${{ secrets.DB1_PASSWORD }}
          DB_DRIVER: ${{ secrets.DB_DRIVER }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          REDIS_PORT: ${{ secrets.REDIS_PORT }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          JWT: ${{ secrets.JWT }}
          S3_BUCKET: ${{ secrets.S3_BUCKET }}
          S3_ACCESS_KEY: ${{ secrets.S3_ACCESS_KEY }}
          S3_SECRET_KEY: ${{ secrets.S3_SECRET_KEY }}
          S3_CLIENT: ${{ secrets.S3_CLIENT }}
          S3_REGION: ${{ secrets.S3_REGION }}
          GOOGLE_MAIL: ${{ secrets.GOOGLE_MAIL }}
          GOOGLE_APP_PASSWORD: ${{ secrets.GOOGLE_APP_PASSWORD }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          GEMINI_PROJECT_ID: ${{ secrets.GEMINI_PROJECT_ID }}
          GEMINI_MODEL: ${{ secrets.GEMINI_MODEL }}
          GEMINI_TEMPERATURE: ${{ secrets.GEMINI_TEMPERATURE }}
          QWEN_API_URL: ${{ secrets.QWEN_API_URL }}
          QWEN_API_KEY: ${{ secrets.QWEN_API_KEY }}
          QWEN_MODEL: ${{ secrets.QWEN_MODEL }}
          QWEN_TEMPERATURE: ${{ secrets.QWEN_TEMPERATURE }}
          LLM_TIMEOUT: ${{ secrets.LLM_TIMEOUT }}
          LLM_MAX_RETRIES: ${{ secrets.LLM_MAX_RETRIES }}
          DB_CONNECTION_TIMEOUT: ${{ secrets.DB_CONNECTION_TIMEOUT }}
          DB_MAX_POOL_SIZE: ${{ secrets.DB_MAX_POOL_SIZE }}
          DB_MIN_IDLE: ${{ secrets.DB_MIN_IDLE }}
          DB_MAX_LIFETIME: ${{ secrets.DB_MAX_LIFETIME }}
          DB_IDLE_TIMEOUT: ${{ secrets.DB_IDLE_TIMEOUT }}
          DB_LEAK_DETECTION_THRESHOLD: ${{ secrets.DB_LEAK_DETECTION_THRESHOLD }}
          DB_POOL_NAME: ${{ secrets.DB_POOL_NAME }}
          REDIS_TIMEOUT: ${{ secrets.REDIS_TIMEOUT }}
          REDIS_CONNECT_TIMEOUT: ${{ secrets.REDIS_CONNECT_TIMEOUT }}
          MAIL_HOST: ${{ secrets.MAIL_HOST }}
          MAIL_PORT: ${{ secrets.MAIL_PORT }}
          MAIL_SMTP_AUTH: ${{ secrets.MAIL_SMTP_AUTH }}
          MAIL_SMTP_STARTTLS_ENABLE: ${{ secrets.MAIL_SMTP_STARTTLS_ENABLE }}
          MAIL_SMTP_STARTTLS_REQUIRED: ${{ secrets.MAIL_SMTP_STARTTLS_REQUIRED }}
          MAX_FILE_SIZE: ${{ secrets.MAX_FILE_SIZE }}
          MAX_REQUEST_SIZE: ${{ secrets.MAX_REQUEST_SIZE }}
          APP_LATEST_VERSION: ${{ secrets.APP_LATEST_VERSION }}
        run: |
          # docker.env ÌååÏùº ÏÉùÏÑ±
          cat > /tmp/docker.env << ENVFILE
          DB1_URL=${DB1_URL}
          DB1_USERNAME=${DB1_USERNAME}
          DB1_PASSWORD=${DB1_PASSWORD}
          DB_DRIVER=${DB_DRIVER}
          SPRING_DATA_REDIS_HOST=${REDIS_URL}
          SPRING_DATA_REDIS_PORT=${REDIS_PORT}
          REDIS_URL=${REDIS_URL}
          REDIS_PORT=${REDIS_PORT}
          REDIS_PASSWORD=${REDIS_PASSWORD}
          JWT=${JWT}
          S3_BUCKET=${S3_BUCKET}
          S3_ACCESS_KEY=${S3_ACCESS_KEY}
          S3_SECRET_KEY=${S3_SECRET_KEY}
          S3_CLIENT=${S3_CLIENT}
          S3_REGION=${S3_REGION}
          GOOGLE_MAIL=${GOOGLE_MAIL}
          GOOGLE_APP_PASSWORD=${GOOGLE_APP_PASSWORD}
          FRONTEND_URL=${FRONTEND_URL}
          GEMINI_API_KEY=${GEMINI_API_KEY}
          GEMINI_PROJECT_ID=${GEMINI_PROJECT_ID}
          GEMINI_MODEL=${GEMINI_MODEL}
          GEMINI_TEMPERATURE=${GEMINI_TEMPERATURE}
          QWEN_API_URL=${QWEN_API_URL}
          QWEN_API_KEY=${QWEN_API_KEY}
          QWEN_MODEL=${QWEN_MODEL}
          QWEN_TEMPERATURE=${QWEN_TEMPERATURE}
          LLM_TIMEOUT=${LLM_TIMEOUT}
          LLM_MAX_RETRIES=${LLM_MAX_RETRIES}
          DB_CONNECTION_TIMEOUT=${DB_CONNECTION_TIMEOUT}
          DB_MAX_POOL_SIZE=${DB_MAX_POOL_SIZE}
          DB_MIN_IDLE=${DB_MIN_IDLE}
          DB_MAX_LIFETIME=${DB_MAX_LIFETIME}
          DB_IDLE_TIMEOUT=${DB_IDLE_TIMEOUT}
          DB_LEAK_DETECTION_THRESHOLD=${DB_LEAK_DETECTION_THRESHOLD}
          DB_POOL_NAME=${DB_POOL_NAME}
          REDIS_TIMEOUT=${REDIS_TIMEOUT}
          REDIS_CONNECT_TIMEOUT=${REDIS_CONNECT_TIMEOUT}
          MAIL_HOST=${MAIL_HOST}
          MAIL_PORT=${MAIL_PORT}
          MAIL_SMTP_AUTH=${MAIL_SMTP_AUTH}
          MAIL_SMTP_STARTTLS_ENABLE=${MAIL_SMTP_STARTTLS_ENABLE}
          MAIL_SMTP_STARTTLS_REQUIRED=${MAIL_SMTP_STARTTLS_REQUIRED}
          MAX_FILE_SIZE=${MAX_FILE_SIZE}
          MAX_REQUEST_SIZE=${MAX_REQUEST_SIZE}
          APP_LATEST_VERSION=${APP_LATEST_VERSION}
          FIREBASE_CONFIG_PATH=/opt/replant/firebase/replant-admin.json
          ENVFILE

          scp -o StrictHostKeyChecking=no -i /tmp/id_rsa /tmp/docker.env ${EC2_USER}@${EC2_HOST}:/tmp/docker.env

          ssh -o StrictHostKeyChecking=no -i /tmp/id_rsa ${EC2_USER}@${EC2_HOST} \
          "IMAGE_REF='${IMAGE_REF}' CONTAINER_NAME='${CONTAINER_NAME}' DOCKER_USER='${DOCKER_USER}' DOCKER_PASS='${DOCKER_PASS}' bash -s" << 'EOF'
            set -euo pipefail

            # Docker ÏÑ§Ïπò Î∞è ÏãúÏûë (ÏÉùÎûµ Í∞ÄÎä•ÌïòÎ©¥ ÏÉùÎûµ)
            if ! command -v docker >/dev/null 2>&1; then
              sudo yum -y install docker || sudo apt-get install -y docker.io
              sudo systemctl start docker
            fi

            echo "${DOCKER_PASS}" | sudo docker login -u "${DOCKER_USER}" --password-stdin
            sudo docker pull "${IMAGE_REF}"
            sudo docker stop "${CONTAINER_NAME}" 2>/dev/null || true
            sudo docker rm "${CONTAINER_NAME}" 2>/dev/null || true

            chmod 600 /tmp/docker.env
            sudo docker run -d \
              -p 8080:8080 \
              --restart unless-stopped \
              --name "${CONTAINER_NAME}" \
              --env-file /tmp/docker.env \
              -v /opt/replant/firebase/replant-admin.json:/opt/replant/firebase/replant-admin.json:ro \
              "${IMAGE_REF}"

            rm -f /tmp/docker.env
            sudo docker image prune -f
          EOF

          rm -f /tmp/docker.env

      # Î∞∞Ìè¨ Í≤∞Í≥º Slack ÏïåÎ¶º
      - name: Send Deployment Result to Slack
        if: always() # Î∞∞Ìè¨ Ïã§Ìå® ÏãúÏóêÎèÑ Ïã§Ìñâ
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          STATUS: ${{ job.status }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          if [ "${STATUS}" = "success" ]; then
            EMOJI="‚úÖ"
            MESSAGE="Î∞∞Ìè¨ ÏÑ±Í≥µ (Deployment Success)"
          else
            EMOJI="üö®"
            MESSAGE="Î∞∞Ìè¨ Ïã§Ìå® (Deployment Failed)"
          fi
          
          curl -X POST -H 'Content-type: application/json' \
            --data "{\"text\": \"${EMOJI} ${MESSAGE}\n‚Ä¢ Repo: ${REPO}\n‚Ä¢ Log: ${RUN_URL}\"}" \
            "$SLACK_WEBHOOK_URL"
